# Домашнее задание №2

## Формат сдачи

--To be specified--

Под каждое задание отведен отдельный файл (например, `task_1.py` для задания №1).
Используйте заготовки внутри этих файлов для своего решения


## Дедлайн и алгоритм оценивания

**Мягкий дедлайн**\
26.11.2024 23:59\
**Жёсткий дедлайн**\
29.11.2024 23:59

**Максимальный балл:** 8 баллов (+1 бонусный балл)

**Если работа сдана до мягкого дедлайна**\
Балл за задание рассчитывается по формуле: $\text{Балл за дз} = min(\text{Балл за дз}, 8)$.


**Если работа сдана после мягкого дедлайна**\
Балл за задание рассчитывается по формуле:

$\text{Балл за дз} = max(0, \text{Балл за дз} \times \text{Штраф})$\
$\text{Штраф} = (1-(\dfrac{(\dfrac{x}{1440})}{3})^2), \text{где x -количество минут после мягкого дедлайна}$

Так, опоздав на сутки (1440 минут), штраф составит $1-\frac{1}{25}=0.88$ (т.е. лишаетесь 12% оценки)\
Штраф снимает баллы нелинейно. Опоздав более чем на 3 дня, оценка составит 0 баллов.


# Задачи



## Задача 1. Римские цифры (2 балла)

Напишите функцию, которая переводит число, записанное римскими цифрами, в число, записанное арабскими цифрами.
Символы для римских цифр:

```
I - 1
V - 5
X - 10
L - 50
C - 100
D - 500
M - 1000
```

Например:
- римская запись II эквивалентна арабской записи 2
- XII записывается как 12, т.е. Х + II
- XXVII -> 27, т.е. XX + V + II

Римские цифры обычно записываются от большего к меньшему слева направо. (будем считать, что так и есть). Но есть некоторая особенность.
Запись 4 - это не  IIII. Вместо этого число четыре записывается как IV, потому что если I стоит перед V, мы "вычитаем его", получая тем самым четыре. Тот же принцип работает и для числа девять, которое записывается как IX. 

Существует шесть случаев, когда используется вычитание:
```
I может быть помещен перед V (5) и X (10) для получения 4 и 9.
X может быть помещен перед L (50) и C (100) для получения 40 и 90.
C может быть помещен перед D (500) и M (1000), чтобы получить 400 и 900.
```

Ваша реализация должна учитывать эти особенности. Используйте шаблон, предоставленный в файле `task_1.py`

## Задача 2. Сравнение множеств (1 балл)

Мы уже знаем, что с множествами можно выполнять различные операции (пересечение, объединение, вычитание и т.д.). Иногда нам хочется иметь ответ не на вопрос "Какие элементы двух множеств содержатся в обоих множеств", а на вопрос "Насколько эти два множества похожи?"

Существуют разные подходы к оценке того, насколько две группы объектов схожи. Одним из таких способов является подсчёт коэффициента Жаккара (Jaccard index). Формально он задаётся следующим образом:

$$J(A, B) = \frac{|A \cap B|}{|A \cup B|}$$
где A, B - два множества. Т.е. мера Жаккара - это отношение мощности пересечения двух множеств (числа элементов, содержащихся в обоих множествах) к мощности объединения этих множеств 

Например, пусть A = {1, 2, 3}, B = {2, 3, 5}. Тогда:

$|A \cap B| = |\{2, 3\}|$, $|A \cup B| = |\{1, 2, 3, 5\}|$
И тогда $J(A, B) = \frac{2}{4} = 0.5$

Напишите функцию, которая принимает на вход два множества и возвращает коэффициент Жаккара для этих множеств. 

**Примечания**:
1) Используйте шаблон из файла `task_2.py`
2) Не нужно менять название функции из шаблона
3) Не нужно добавлять input() в код. Реализация функции - это всё, что нужно

## Задача 3. Hots in your area (2 балла)

Многие дейтинговые приложения используют для улучшения пользовательского опыта (среди прочего) информацию о местоположении двух пользователей. Эта информация позволяет сделать выдачу анкет пользователей более релевантной (например, позволяя пользователем явно ограничивать дистанцию до своих потенциальных собеседников). Если вы знакомы с каким-либо дейтинговым сервисом, то, вероятно, такой фильтр "расстояния" вам знаком. 

Вам необходимо реализовать функцию, которая:
- принимает на вход два списка, каждый из которых содержит широту и долготу (две точки, отвечающие за местоположение двух пользователей)
- возвращает расстояние между этими точками, округленный до целого числа километров

Оказывается, что, если бы дейтинговые сервисы честно (и точно) сообщали расстояние между пользователями, можно было бы относительно точно узнать местоположение другого человека с помощью [трилатерации](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B8%D0%BB%D0%B0%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F). Трижды меняя своё местоположение (с помощью специализированного софта) и находя каждый раз анкету одного и того же человека, пользователь мог бы вычислить его местоположение: оно бы лежало на пересечении окружностей, центрами которых бы являлись новые локации, а радиусами - расстояния до интересующего собеседника. Иллюстрация:

![trilat_insecure](https://bluefletch.com/wp-content/uploads/2019/08/tri.png)

Решение данной проблемы сводится к различным способам выдачи несколько искаженного расстояния (не слишком сильно, чтобы сохранять смысл фильтра пользователей по расстоянию, но и не слишком слабо, чтобы обеспечить некоторый уровень безопасности). Искажение как правило происходит ещё на этапе подсчёта расстояний между двумя координатами - например, можно предположить, что земная поверхность ещё более искривлённая, чем на самом деле. В данной домашке от вас не требуется реализация подобного искривления (или других вариантов решения проблемы), но информация - a nice thing to keep in mind.

**Важные примечания**:

**Примечание раз.** Расстояние между двумя точками на Земле - не то же самое, что расстояние между двумя точками на плоскости. Здесь (ожидаемо или неожиданно - зависит от вас) всплывает тригонометрия :) Я даю вам два варианта:
1) Закодить подсчёт расстояние между двумя координатами в формате (широта, долгота) самостоятельно (обязательно укажите в коде, откуда вы взяли решение, если вы найдёте его в интернете; в случае обнаружения плагиата я поставлю 0 за всё задание). В случае верной реализации за задание выставлю полный балл
2) Использовать сторонние библиотеки, которые считают расстояние за вас. Я зачту такое решение, но выше 1 балла за задание не поставлю

**Примечание два**. Если вам нужно где-то использовать радиус Земли - возьмите R = 6378100 метров

---
Пример:

```python
coords_1 = [59.9433727, 30.2903071]  # корпус ИТМО на Биржевой
coords_2 = [59.9571826, 30.303468]  # корпус ИТМО на Кронверкском

print(find_distance(coords_1, coords_2))  # -> 2
```

## Задача 4. Color mixer (2 балла)

Существует не единственный способ кодирования цветов в виде чисел (существует не единственная цветовая модель). RGB - вероятно, наиболее знакомая большинству форма записи цвета, заключающаяся в разбивке на три цветовых канала, где сложение этих каналов даёт результирующий цвет, однако модель RGB не единственная. 

Если захотите больше узнать про это, можно начать, например, с этого [видео](https://youtu.be/99v96TL-tuY?si=sf_soEPeYBiiS4Hy), но в данном задании мы всё-таки будем работать с RGB.

Необходимо написать функцию, которая:
- принимает на вход произвольное число строк, соответствующее цветовым кодам в формате HEX
- возвращает цвет в формате HEX, отвечающий среднему среди поданных на вход

Как производить усреднение?
- переведите цвета из формата HEX в RGB - гугл в помощь:) это делается довольно просто
- произведите усреднение цветовых каналов. Здесь важная вещь - нельзя просто так взять и усреднить цветовые каналы через среднее арифметическое - это связано с особенностями того, как мы воспринимаем цвета. Почитайте про это, например, [здесь](https://stackoverflow.com/questions/649454/what-is-the-best-way-to-average-two-colors-that-define-a-linear-gradient) и посмотрите вот [это видео](https://www.youtube.com/watch?v=LKnqECcg6Gw)
- после усреднения каждого цветового канала переведите RGB обратно в HEX

**Примечания**
- Если вы найдете специальный модуль, который реализует цветовое усреднение или переводит цвета между разными форматами (HEX <-> RGB), и решите его использовать, я поставлю максимум 1 балл при верной реализации
- Используйте шаблон, предоставленный в файле task_4.py
- Принты и инпуты добавлять в программу не нужно 

---
Пример:
```python
color_1, color_2 = "#3ca832", "#5032a8"
print(color_averager(color_1, color_2))  # -> #467b7b
```


## Задача 5. Генератор случайных чисел (2 балла)

Задание на креатив, в котором вам предстоит убедиться в том, что компьютеры как правило генерируют не случайные, а псевдослучайные числа!

Вам нужно написать генератор, который генерирует случайные целые числа $\in [0; 100]$ . Как? Зависит от вас! По сути, генерация случайных чисел делится на генерацию случайных и псевдослучайных чисел:
- **Случайные числа** - такие числа, генерация которых основана на каком-то действительно случайном процессе. Проблема здесь в том, что компьютеру откуда-то нужно брать информацию о таких процессах. Например, атмосферное давление/точное текущее время
- **Псевдослучайные числа** - такие числа, генерация которых не основана на каком-то случайном процессе. Вместо этого она как правило основана на результате последовательного применения некоторых математических операций. Для начала можете погуглить LCG (линейный конгруэнтный метод)

**Примечания**
- Используйте шаблон из файла `task_5.py`. Добавьте в файл пример генерации пяти случайных чисел (выведите их через `print`). Отсутствие примера ведёт к штрафу в 0.5 баллов
- Ваш алгоритм может генерировать как случайные числа, так и псевдослучайные, оба варианта при верной реализации (и наличии примера) получат максимальный балл
- Если вы возьмёте LCG в качестве решения, при верной реализации (и наличии примера) я не поставлю вам больше 1 балла
- Если вы решите использовать встроенный модуль random, при верной реализации (и наличии примера) я не поставлю вам больше 0.5 баллов. То же касается любых других встроенных модулей, реализующих из коробки генерацию случайных чисел 
